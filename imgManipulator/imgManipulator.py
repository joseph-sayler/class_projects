# Joseph Sayler
# CSC 110 HW8
# 3/18/2016
# This program takes a user specified .ppm file and performs 3 different image
# conversions on it:
#   1) Flips the image horizontally
#   2) Negates the color red from all pixels in the image
#   3) Converts image to grayscale

def main():
    intro()
    imageFile = input('Enter name of image file: ')
    
    # lets user know that the file needs to be .ppm and if file exists
    while valid_file(imageFile) != True:
        if imageFile.endswith('.ppm') == False:
            print('All valid files must have a .ppm extention.\n')
        else:
            print('That file does not exist, please try again.\n')
        imageFile = input('Please enter a valid file name: ')
    
    # creates a tuple to hold the contents of the imported file
    # which helps retain the integrity of the original data
    ppmTuple = tuple(read_ppm(imageFile))
    
    write_ppm('fl_' + imageFile, horizontal_flip(ppmTuple))
    write_ppm('nr_' + imageFile, negate_red(ppmTuple))
    write_ppm('gr_' + imageFile, grayscale(ppmTuple))
    
    print('\nThe image manipulations are done.')
    print('The new file names are:')
    print('fl_' + imageFile)
    print('nr_' + imageFile)
    print('gr_' + imageFile)
    print('')

#==================== file processing functions =====================#

# gets name of file to open from user and also checks if file exists
#   name: holds the file name given by user
#   dataFile: contains the open file (if it exists)
def valid_file(name):
    try:
        dataFile = open(name,'r')
        dataFile.close()
    except: # this catches all exceptions
        return False
    return True

# this function takes in no parameters, opens a file specified by the
# user (checks file exists first), reads file, stores it in a
# variable, then splits the file up and puts it into a list, and returns
# that list
#   filename: the file name given by user
#   array: the list holding the initial data from the ppm file
#   ppm: the opened ppm file specified by user
#   numbers: contains contents of entire ppm file, stripped of any whitespace
def read_ppm(filename):
    array = []
    ppm = open(filename,'r')
    numbers = ppm.read().strip()
    ppm.close()
    array = numbers.split()
    return array

# this function takes the array from read_ppm and writes it to a file
# the file is formatted so the first 4 elements occupy the first 3 lines
# then each line thereafter will hold 3 elements each (representing the
# RGB values of each pixel
#   filename: name of the user specified file. this is used for creating
#             the new file's name
#   array: points to the list generated by one of the image processing
#          functions
#   index: used to keep track of what index the loop is processing
#   writefile: points to the open file where data is written into. uses
#              the filename variable as part of the new file's name
def write_ppm(filename,array):
    writefile = open(filename,'w')
    # sets up the header information, making it 3 lines
    writefile.write(array[0] + '\n') # P3
    writefile.write(array[1] + ' ' + array[2] + '\n') # image size, xxx yyy
    writefile.write(array[3] + '\n') # 255
    index = 4
    # this loop puts 3 elements per line, making it easier
    # to read when you view it in a text editor
    while index < len(array):
        writefile.write(array[index] + ' ')
        writefile.write(array[index + 1] + ' ')
        writefile.write(array[index + 2] + '\n')
        index += 3
    writefile.close()

#====================================================================#

#==================== image processing functions ====================#

# this function reverses the order of the list elements. since a pixel
# is made up of 3 elements from the list, it preserves this order (RGB)
# but shifts their position in the list. so first pixel (elements 1,2,3)
# are at the end, then the next pixel (elements 4,5,6) and so on
#   array1: this points to the tuple made in main() and serves as the
#           master data for the image
#   array2: a copy of array1, all data from array1 is appended to it
#   index: used to keep track of what index the loop is processing
def horizontal_flip(array1):
    array2 = list(array1[:4]) # header
    index = len(array1) - 1 # starts at end of array
    while index >= 4: # ends at header
        array2.append(array1[index - 2])
        array2.append(array1[index - 1])
        array2.append(array1[index])
        index -= 3
    return array2

# processes each pixel, negating the red value. this is done by taking the
# absolute value of the difference between array1[index] - 255 (the maximum
# value that red can have). this is only applied to the first value in the
# pixel, which corresponds to Red. Green and Blue are untouched. since Red
# has to undergo arithmetic operation, it is converted to int, then str again.
# this saves having to convert the entire list to int first
#   array1: this points to the tuple made in main() and serves as the
#           master data for the image
#   array2: a copy of array1, all data from array1 is appended to it
#   index: used to keep track of what index the loop is processing
def negate_red(array1):
    array2 = list(array1[:4]) # header
    index = 4
    while index < len(array1) - 1:
        # to do arithmetic, element must be int first, then back to str
        # for concatenation
        array2.append(str(abs(int(array1[index]) - 255))) # red negated
        array2.append(array1[index + 1])# green untouched
        array2.append(array1[index + 2]) # blue untouched
        index += 3
    return array2

# this function takes the average RGB value for one pixel and assigns
# that value for all RGB elements in the pixel, making the image gray.
#   array1: this points to the tuple made in main() and serves as the
#           master data for the image
#   array2: a copy of array1, all data from array1 is appended to it
#   index: used to keep track of what index the loop is processing
#   grValue: this is the average of R, G, and B in the pixel. all RGB
#            values are changed to this averaged value
def grayscale(array1):
    array2 = list(array1[:4]) # header
    index = 4
    while index < len(array1) - 1:
        # all values converted to int for math, then str for concatenation
        grValue = str((int(array1[index]) + int(array1[index + 1]) + \
                       int(array1[index + 2]))//3)
        array2.append(grValue)
        array2.append(grValue)
        array2.append(grValue)
        index += 3
    return array2

#====================================================================#

def intro():
    print('\n============== PPM Image Manipulation Program ==============\n')
    print('This program manipulates the data of .ppm files. The data in')
    print('these files is plain text, and can be manipulated in a text')
    print('editor if one wishes.\n')
    print('The program performs 3 manipulations to the image file you')
    print('specify: 1) the image is flipped horizontally; 2) the color')
    print('red is negated; 3) all color is converted to grayscale. A')
    print('new image file will be created after each file manipulation.\n')
    print('The new files will have a prefix based upon the manipulation')
    print('being performed:\n')
    print('\t\t\"fl_\" for flip')
    print('\t\t\"nr_\" for negate red')
    print('\t\t\"gr_\" for grayscale\n')
    print('===========================================================\n')

main()

